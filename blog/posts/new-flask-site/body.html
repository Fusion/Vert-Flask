{% extends "templates/post.html" %}
{% block post %}
{% filter markdown %}


[{{post['title']}}]({{post['url']}})
======================================

[Flask](http://flask.pocoo.org/) is a Python web framework that's steadily
increasing in popularity within the webdev world. After reading so many 
great things about Flask, I decided to try it out myself. I personally find 
testing out a new framework difficult, because you must find a project complex 
enough to reveal the framework's quirks, but not so daunting as to take the 
fun out of the project. Luckily, my PHP/Wordpress powered website filled this
role quite nicely - the website simply consists of static content, a contact
page, and a blog. If I could not convert such a simple site over to Flask, 
I would immediately know that Flask and I would not make a good team.

Spoiler alert: You're reading this on a Flask powered site!

Getting Started
---------------

The first task at hand was simply getting the home, about, services, and work
pages to render correctly. While the task consisted mostly of copying and 
pasting, I was able to immediately apply most of the concepts from the
[Flask quickstart guide][0]. Specifically, I had to learn


* How do I actually start the server?
* Where do my templates go?
* Where do my static assets go?
* How do I retrieve my assets from within the templates?
* How do I route requests?

Sure enough, getting the pure HTML documents to render was pretty simple.
By pure HTML, I mean there were no includes for headers, footers, etc. Thus 
the logical next step was to take these pure HTML documents and DRY up the 
repeating areas.

Growing pains...already?!
------------------------

Coming from PHP, I was used to just `include`-ing the content I wanted and being
done with it.  [Jinja2](http://jinja.pocoo.org/docs/), Flask's default
templating engine, does not currently support includes. (Note: An `include` 
function [does exist](http://jinja.pocoo.org/docs/templates/#include). However,
I could not get the include function to return non-escaped html. Perhaps this
function was broken in a recent build). Jinja does, however, have 
[template inheritance][1]. To demonstrate, suppose we have a parent 
template `layout.html` 

{% raw %}
<pre class="prettyprint">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;&lt;title&gt;My Website&lt;/title&gt; &lt;/head&gt;
  &lt;body&gt;
  &lt;div id="wrapper"&gt;
    &lt;div id="content"&gt;
      {% block body %}{% endblock body %}
    &lt;/div&gt;&lt;!--content--&gt;
  &lt;/div&gt;&lt;!--wrapper--&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
{% endraw %}

And a child template `index.html` that inherits the parent and fills in its
blocks
{% raw %}
<pre class="prettyprint">{% extends "layout.html" %}
{% block body %}
  Body content goes here!
{% endblock body %}
</pre>
{% endraw %}

If we were to call [render_template][2] on `index.html`, this is what we
would get.

<pre class="prettyprint">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;&lt;title&gt;My Website&lt;/title&gt; &lt;/head&gt;
  &lt;body&gt;
  &lt;div id="wrapper"&gt;
    &lt;div id="content"&gt;
      Body content goes here!
    &lt;/div&gt;&lt;!--content--&gt;
  &lt;/div&gt;&lt;!--wrapper--&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

I like the template inheritance pattern of Jinja, but the lack of an include
statement can easily lead to huge parent templates. 

Thankfully, I did find a sufficient workaround to the lack of an include 
statement. Jinja lets you define [Macros][4], which are essentially functions
used within templates to render something. I defined a macro called `nav` that
simply returned the HTML for the navigation. I did the same thing for `header`,
`footer`, and any other sections repeated throughout the site. Take our 
footer, for example.

{% raw %}
<pre class="prettyprint">
{% macro footer() %}
&lt;div id="footer"&gt;
  &lt;div class="hr"&gt;&lt;hr /&gt;&lt;/div&gt;
  &lt;p&gt;
    &lt;a href="mailto:hi@vertstudios.com"&gt;hi@vertstudios.com&lt;/a&gt; |
    &lt;a href="http://www.twitter.com/vertstudios"&gt;@vertstudios&lt;/a&gt;
  &lt;/p&gt;
&lt;/div&gt;
{% endmacro  %}
</pre>
{% endraw %}

Then, from `layouts.html`, I could call the footer macro. Flask requires the 
use of the `|safe` filter if you want to render the returned string. Thus, a 
macro `foo()` can be called from a macro `bar()` without the need to specify 
`{{'{{'}}foo()|safe{{'}}'}}`. But since `layouts.html` is something being
directly rendered, we need to specify `|safe` every time we call a macro.

So the final `layouts.html` ended up looking like

{% raw %}
<pre class="prettyprint">
{% from "sections" import meta_and_css, nav, javascripts, footer %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  {{ meta_and_css(g, title)|safe }}
  &lt;body onload="prettyPrint()" id="{{g.bodyID}}"&gt;
&lt;div id="wrapper"&gt;
  {{ nav(g)|safe }}
  &lt;div id="content"&gt;
    {% block body %}{% endblock body %}
  &lt;/div&gt;&lt;!--content--&gt;
  {{ footer()|safe }}
&lt;/div&gt;&lt;!--wrapper--&gt;
{{ javascripts(g)|safe }}
&lt;/body&gt;
&lt;/html&gt;
</pre>
{% endraw %}

This was less than ideal, but it worked; a recurring theme throughout the 
development process that surprisingly didn't bother me so much. 

Being 'Brave'
-------------

Flask didn't always have an out-of-the-box solution to the problem at hand. In 
fact, it *rarely* did. Flask did, however, give me all the tools necessary to 
create whatever I wanted. In a way, I felt that Flask itself was telling me
"Joseph, you're smart enough to implement X functionality on your own... be 
brave for once!"

Sometimes reinventing the wheel is a rewarding exercise. 

The Contact Form
----------------

The recommended method of dealing with forms in Flask is the [Flask-WTF][5]
extension. Flask-WTF has many [built in validation methods][6], but it did not
include validation for a phone number. No big deal, any form library worth its
salt has means for defining custom validation functions. WTForms does in fact
have a mechanism for implementing [custom validators][7], but I did not find 
their examples very pleasing to the eye:

<pre class="prettyprint">
def length(min=-1, max=-1):
    message = 'Must be between %d and %d characters long.' % (min, max)

    def _length(form, field):
        l = field.data and len(field.data) or 0
        if l < min or max != -1 and l > max:
            raise ValidationError(message)

    return _length

class MyForm(Form):
    name = TextField('Name', [Required(), length(max=50)])
</pre>

Consequently, I used Flask-WTF to gather data from the form fields, but I 
rolled my own validation module, which only took about an hour. 





[0]: http://flask.pocoo.org/docs/quickstart
[1]: http://jinja.pocoo.org/docs/templates/#template-inheritance
[2]: http://flask.pocoo.org/docs/quickstart/#rendering-templates
[3]: http://flask.pocoo.org/community/poweredby/
[4]: http://jinja.pocoo.org/docs/templates/#macros
[5]: http://packages.python.org/Flask-WTF/
[6]: http://flask.pocoo.org/docs/patterns/wtforms/#the-forms
[7]: http://wtforms.simplecodes.com/docs/1.0.1/validators.html

{% endfilter %}
{% endblock post %}

